// Copyright Epic Games, Inc. All Rights Reserved.

// WARNING: This code is autogenerated by VerseVMBytecodeGenerator.cs. Do not edit directly

#pragma once

// IWYU pragma: private, include "VVMBytecodesAndCaptures.h"

namespace Verse {
struct FOpAdd : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Add;
    static constexpr bool bHasJumps = false;

    FOpAdd(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpAdd) >= 8);

struct FOpSub : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Sub;
    static constexpr bool bHasJumps = false;

    FOpSub(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpSub) >= 8);

struct FOpMul : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Mul;
    static constexpr bool bHasJumps = false;

    FOpMul(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpMul) >= 8);

struct FOpDiv : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Div;
    static constexpr bool bHasJumps = false;

    FOpDiv(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpDiv) >= 8);

struct FOpMod : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Mod;
    static constexpr bool bHasJumps = false;

    FOpMod(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpMod) >= 8);

struct FOpMutableAdd : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::MutableAdd;
    static constexpr bool bHasJumps = false;

    FOpMutableAdd(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpMutableAdd) >= 8);

struct FOpNeg : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Source;

    static constexpr EOpcode StaticOpcode = EOpcode::Neg;
    static constexpr bool bHasJumps = false;

    FOpNeg(const FRegisterIndex InDest, const FValueOperand InSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Source(InSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Source);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Source, "Source");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Source);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Source, "Source");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNeg) >= 8);

struct FOpQuery : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Source;

    static constexpr EOpcode StaticOpcode = EOpcode::Query;
    static constexpr bool bHasJumps = false;

    FOpQuery(const FRegisterIndex InDest, const FValueOperand InSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Source(InSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Source);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Source, "Source");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Source);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Source, "Source");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpQuery) >= 8);

struct FOpErr : public FOp
{

    static constexpr EOpcode StaticOpcode = EOpcode::Err;
    static constexpr bool bHasJumps = false;

    FOpErr()
        : FOp(StaticOpcode)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpErr) >= 8);

struct FOpMove : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Source;

    static constexpr EOpcode StaticOpcode = EOpcode::Move;
    static constexpr bool bHasJumps = false;

    FOpMove(const FRegisterIndex InDest, const FValueOperand InSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Source(InSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Source);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Source, "Source");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Source);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Source, "Source");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpMove) >= 8);

struct FOpReset : public FOp
{
    FRegisterIndex Dest;

    static constexpr EOpcode StaticOpcode = EOpcode::Reset;
    static constexpr bool bHasJumps = false;

    FOpReset(const FRegisterIndex InDest)
        : FOp(StaticOpcode)
        , Dest(InDest)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::ClobberDef, Dest);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::ClobberDef, Dest, "Dest");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::ClobberDef, Dest);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::ClobberDef, Dest, "Dest");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpReset) >= 8);

struct FOpJump : public FOp
{
    FLabelOffset JumpOffset;

    static constexpr EOpcode StaticOpcode = EOpcode::Jump;
    static constexpr bool bHasJumps = true;

    FOpJump(FLabelOffset JumpOffset)
        : FOp(StaticOpcode)
        , JumpOffset(JumpOffset)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
        Function(JumpOffset);
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
        Function(JumpOffset, "JumpOffset");
    }

};
static_assert(alignof(FOpJump) >= 8);

struct FOpBeginFailureContext : public FOp
{
    FLabelOffset OnFailure;

    static constexpr EOpcode StaticOpcode = EOpcode::BeginFailureContext;
    static constexpr bool bHasJumps = true;

    FOpBeginFailureContext(FLabelOffset OnFailure)
        : FOp(StaticOpcode)
        , OnFailure(OnFailure)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
        Function(OnFailure);
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
        Function(OnFailure, "OnFailure");
    }

};
static_assert(alignof(FOpBeginFailureContext) >= 8);

struct FOpEndFailureContext : public FOp
{
    FLabelOffset Done;

    static constexpr EOpcode StaticOpcode = EOpcode::EndFailureContext;
    static constexpr bool bHasJumps = true;

    FOpEndFailureContext(FLabelOffset Done)
        : FOp(StaticOpcode)
        , Done(Done)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
        Function(Done);
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
        Function(Done, "Done");
    }

};
static_assert(alignof(FOpEndFailureContext) >= 8);

struct FOpCall : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Callee;
    // Variadic arguments.
    TArray<FValueOperand> Arguments;

    static constexpr EOpcode StaticOpcode = EOpcode::Call;
    static constexpr bool bHasJumps = false;

    FOpCall(const FRegisterIndex InDest, const FValueOperand InCallee, TArray<FValueOperand>&& InArguments)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Callee(InCallee)
        , Arguments(InArguments)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Callee);
        for (const auto& Operand : Arguments)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Callee, "Callee");
        for (int32 Index = 0; Index < Arguments.Num(); ++Index)
        {
            auto& Operand = Arguments[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Arguments", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Callee);
        for (const auto& Operand : Arguments)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Callee, "Callee");
        for (int32 Index = 0; Index < Arguments.Num(); ++Index)
        {
            auto& Operand = Arguments[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Arguments", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpCall) >= 8);

struct FOpReturn : public FOp
{
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::Return;
    static constexpr bool bHasJumps = false;

    FOpReturn(const FValueOperand InValue)
        : FOp(StaticOpcode)
        , Value(InValue)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpReturn) >= 8);

struct FOpNewVar : public FOp
{
    FRegisterIndex Dest;

    static constexpr EOpcode StaticOpcode = EOpcode::NewVar;
    static constexpr bool bHasJumps = false;

    FOpNewVar(const FRegisterIndex InDest)
        : FOp(StaticOpcode)
        , Dest(InDest)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNewVar) >= 8);

struct FOpVarGet : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Var;

    static constexpr EOpcode StaticOpcode = EOpcode::VarGet;
    static constexpr bool bHasJumps = false;

    FOpVarGet(const FRegisterIndex InDest, const FValueOperand InVar)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Var(InVar)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Var);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Var, "Var");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Var);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Var, "Var");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpVarGet) >= 8);

struct FOpVarSet : public FOp
{
    FValueOperand Var;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::VarSet;
    static constexpr bool bHasJumps = false;

    FOpVarSet(const FValueOperand InVar, const FValueOperand InValue)
        : FOp(StaticOpcode)
        , Var(InVar)
        , Value(InValue)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Var);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Var, "Var");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Var);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Var, "Var");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpVarSet) >= 8);

struct FOpFreeze : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::Freeze;
    static constexpr bool bHasJumps = false;

    FOpFreeze(const FRegisterIndex InDest, const FValueOperand InValue)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Value(InValue)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpFreeze) >= 8);

struct FOpMelt : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::Melt;
    static constexpr bool bHasJumps = false;

    FOpMelt(const FRegisterIndex InDest, const FValueOperand InValue)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Value(InValue)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpMelt) >= 8);

struct FOpLength : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Container;

    static constexpr EOpcode StaticOpcode = EOpcode::Length;
    static constexpr bool bHasJumps = false;

    FOpLength(const FRegisterIndex InDest, const FValueOperand InContainer)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Container(InContainer)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Container);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Container, "Container");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Container);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Container, "Container");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpLength) >= 8);

struct FOpIndexSet : public FOp
{
    FValueOperand Container;
    FValueOperand Index;
    FValueOperand ValueToSet;

    static constexpr EOpcode StaticOpcode = EOpcode::IndexSet;
    static constexpr bool bHasJumps = false;

    FOpIndexSet(const FValueOperand InContainer, const FValueOperand InIndex, const FValueOperand InValueToSet)
        : FOp(StaticOpcode)
        , Container(InContainer)
        , Index(InIndex)
        , ValueToSet(InValueToSet)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container);
        Function(EOperandRole::Use, Index);
        Function(EOperandRole::Use, ValueToSet);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container, "Container");
        Function(EOperandRole::Use, Index, "Index");
        Function(EOperandRole::Use, ValueToSet, "ValueToSet");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Container);
        Function(EOperandRole::Use, Index);
        Function(EOperandRole::Use, ValueToSet);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Container, "Container");
        Function(EOperandRole::Use, Index, "Index");
        Function(EOperandRole::Use, ValueToSet, "ValueToSet");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpIndexSet) >= 8);

struct FOpNewArray : public FOp
{
    FRegisterIndex Dest;
    // Variadic arguments.
    TArray<FValueOperand> Values;

    static constexpr EOpcode StaticOpcode = EOpcode::NewArray;
    static constexpr bool bHasJumps = false;

    FOpNewArray(const FRegisterIndex InDest, TArray<FValueOperand>&& InValues)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Values(InValues)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNewArray) >= 8);

struct FOpNewMutableArray : public FOp
{
    FRegisterIndex Dest;
    // Variadic arguments.
    TArray<FValueOperand> Values;

    static constexpr EOpcode StaticOpcode = EOpcode::NewMutableArray;
    static constexpr bool bHasJumps = false;

    FOpNewMutableArray(const FRegisterIndex InDest, TArray<FValueOperand>&& InValues)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Values(InValues)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNewMutableArray) >= 8);

struct FOpNewMutableArrayWithCapacity : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Size;

    static constexpr EOpcode StaticOpcode = EOpcode::NewMutableArrayWithCapacity;
    static constexpr bool bHasJumps = false;

    FOpNewMutableArrayWithCapacity(const FRegisterIndex InDest, const FValueOperand InSize)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Size(InSize)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Size);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Size, "Size");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Size);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Size, "Size");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNewMutableArrayWithCapacity) >= 8);

struct FOpArrayAdd : public FOp
{
    FValueOperand Container;
    FValueOperand ValueToAdd;

    static constexpr EOpcode StaticOpcode = EOpcode::ArrayAdd;
    static constexpr bool bHasJumps = false;

    FOpArrayAdd(const FValueOperand InContainer, const FValueOperand InValueToAdd)
        : FOp(StaticOpcode)
        , Container(InContainer)
        , ValueToAdd(InValueToAdd)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container);
        Function(EOperandRole::Use, ValueToAdd);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container, "Container");
        Function(EOperandRole::Use, ValueToAdd, "ValueToAdd");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Container);
        Function(EOperandRole::Use, ValueToAdd);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Container, "Container");
        Function(EOperandRole::Use, ValueToAdd, "ValueToAdd");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpArrayAdd) >= 8);

struct FOpInPlaceMakeImmutable : public FOp
{
    FValueOperand Container;

    static constexpr EOpcode StaticOpcode = EOpcode::InPlaceMakeImmutable;
    static constexpr bool bHasJumps = false;

    FOpInPlaceMakeImmutable(const FValueOperand InContainer)
        : FOp(StaticOpcode)
        , Container(InContainer)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container, "Container");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Container);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Container, "Container");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpInPlaceMakeImmutable) >= 8);

struct FOpNewOption : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::NewOption;
    static constexpr bool bHasJumps = false;

    FOpNewOption(const FRegisterIndex InDest, const FValueOperand InValue)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Value(InValue)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNewOption) >= 8);

struct FOpNewMap : public FOp
{
    FRegisterIndex Dest;
    // Variadic arguments.
    TArray<FValueOperand> Keys;
    TArray<FValueOperand> Values;

    static constexpr EOpcode StaticOpcode = EOpcode::NewMap;
    static constexpr bool bHasJumps = false;

    FOpNewMap(const FRegisterIndex InDest, TArray<FValueOperand>&& InKeys, TArray<FValueOperand>&& InValues)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Keys(InKeys)
        , Values(InValues)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        for (const auto& Operand : Keys)
        {
            Function(EOperandRole::Use, Operand);
        }
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        for (int32 Index = 0; Index < Keys.Num(); ++Index)
        {
            auto& Operand = Keys[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Keys", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        for (const auto& Operand : Keys)
        {
            Function(EOperandRole::Use, Operand);
        }
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        for (int32 Index = 0; Index < Keys.Num(); ++Index)
        {
            auto& Operand = Keys[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Keys", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNewMap) >= 8);

struct FOpMapKey : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Map;
    FValueOperand Index;

    static constexpr EOpcode StaticOpcode = EOpcode::MapKey;
    static constexpr bool bHasJumps = false;

    FOpMapKey(const FRegisterIndex InDest, const FValueOperand InMap, const FValueOperand InIndex)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Map(InMap)
        , Index(InIndex)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Map);
        Function(EOperandRole::Use, Index);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Map, "Map");
        Function(EOperandRole::Use, Index, "Index");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Map);
        Function(EOperandRole::Use, Index);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Map, "Map");
        Function(EOperandRole::Use, Index, "Index");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpMapKey) >= 8);

struct FOpMapValue : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Map;
    FValueOperand Index;

    static constexpr EOpcode StaticOpcode = EOpcode::MapValue;
    static constexpr bool bHasJumps = false;

    FOpMapValue(const FRegisterIndex InDest, const FValueOperand InMap, const FValueOperand InIndex)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Map(InMap)
        , Index(InIndex)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Map);
        Function(EOperandRole::Use, Index);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Map, "Map");
        Function(EOperandRole::Use, Index, "Index");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Map);
        Function(EOperandRole::Use, Index);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Map, "Map");
        Function(EOperandRole::Use, Index, "Index");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpMapValue) >= 8);

struct FOpNewClass : public FOp
{
    FRegisterIndex Dest;
    // Variadic arguments.
    TArray<FValueOperand> Inherited;
    // Immediate arguments.
    TWriteBarrier<VConstructor> Constructor;

    static constexpr EOpcode StaticOpcode = EOpcode::NewClass;
    static constexpr bool bHasJumps = false;

    FOpNewClass(const FRegisterIndex InDest, TWriteBarrier<VConstructor>&& InConstructor, TArray<FValueOperand>&& InInherited)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Inherited(InInherited)
        , Constructor(InConstructor)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Immediate, Constructor);
        for (const auto& Operand : Inherited)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Immediate, Constructor, "Constructor");
        for (int32 Index = 0; Index < Inherited.Num(); ++Index)
        {
            auto& Operand = Inherited[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Inherited", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Immediate, Constructor);
        for (const auto& Operand : Inherited)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Immediate, Constructor, "Constructor");
        for (int32 Index = 0; Index < Inherited.Num(); ++Index)
        {
            auto& Operand = Inherited[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Inherited", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNewClass) >= 8);

struct FOpNewObject : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Class;
    // Variadic arguments.
    TArray<FValueOperand> Values;
    // Immediate arguments.
    TWriteBarrier<VUniqueStringSet> Fields;

    static constexpr EOpcode StaticOpcode = EOpcode::NewObject;
    static constexpr bool bHasJumps = false;

    FOpNewObject(const FRegisterIndex InDest, const FValueOperand InClass, TWriteBarrier<VUniqueStringSet>&& InFields, TArray<FValueOperand>&& InValues)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Class(InClass)
        , Values(InValues)
        , Fields(InFields)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Class);
        Function(EOperandRole::Immediate, Fields);
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Class, "Class");
        Function(EOperandRole::Immediate, Fields, "Fields");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Class);
        Function(EOperandRole::Immediate, Fields);
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand);
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Class, "Class");
        Function(EOperandRole::Immediate, Fields, "Fields");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand, TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNewObject) >= 8);

struct FOpLoadField : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Object;
    // Immediate arguments.
    TWriteBarrier<VUniqueString> Name;

    static constexpr EOpcode StaticOpcode = EOpcode::LoadField;
    static constexpr bool bHasJumps = false;

    FOpLoadField(const FRegisterIndex InDest, const FValueOperand InObject, TWriteBarrier<VUniqueString>&& InName)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , Object(InObject)
        , Name(InName)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Object);
        Function(EOperandRole::Immediate, Name);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Object, "Object");
        Function(EOperandRole::Immediate, Name, "Name");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, Object);
        Function(EOperandRole::Immediate, Name);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, Object, "Object");
        Function(EOperandRole::Immediate, Name, "Name");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpLoadField) >= 8);

struct FOpUnifyField : public FOp
{
    FValueOperand Object;
    FValueOperand Value;
    // Immediate arguments.
    TWriteBarrier<VUniqueString> Name;

    static constexpr EOpcode StaticOpcode = EOpcode::UnifyField;
    static constexpr bool bHasJumps = false;

    FOpUnifyField(const FValueOperand InObject, TWriteBarrier<VUniqueString>&& InName, const FValueOperand InValue)
        : FOp(StaticOpcode)
        , Object(InObject)
        , Value(InValue)
        , Name(InName)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Object);
        Function(EOperandRole::Immediate, Name);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Object, "Object");
        Function(EOperandRole::Immediate, Name, "Name");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Object);
        Function(EOperandRole::Immediate, Name);
        Function(EOperandRole::Use, Value);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Object, "Object");
        Function(EOperandRole::Immediate, Name, "Name");
        Function(EOperandRole::Use, Value, "Value");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpUnifyField) >= 8);

struct FOpNeq : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Neq;
    static constexpr bool bHasJumps = false;

    FOpNeq(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpNeq) >= 8);

struct FOpLt : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Lt;
    static constexpr bool bHasJumps = false;

    FOpLt(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpLt) >= 8);

struct FOpLte : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Lte;
    static constexpr bool bHasJumps = false;

    FOpLte(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpLte) >= 8);

struct FOpGt : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Gt;
    static constexpr bool bHasJumps = false;

    FOpGt(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpGt) >= 8);

struct FOpGte : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Gte;
    static constexpr bool bHasJumps = false;

    FOpGte(const FRegisterIndex InDest, const FValueOperand InLeftSource, const FValueOperand InRightSource)
        : FOp(StaticOpcode)
        , Dest(InDest)
        , LeftSource(InLeftSource)
        , RightSource(InRightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest);
        Function(EOperandRole::Use, LeftSource);
        Function(EOperandRole::Use, RightSource);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest, "Dest");
        Function(EOperandRole::Use, LeftSource, "LeftSource");
        Function(EOperandRole::Use, RightSource, "RightSource");
    }

    template <typename FunctionType>
    FORCEINLINE void ForEachJump(FunctionType Function) const
    {
    }
    template <typename FunctionType>
    FORCEINLINE void ForEachJumpWithName(FunctionType Function) const
    {
    }

};
static_assert(alignof(FOpGte) >= 8);

struct FAddSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FAddSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FAddSuspensionCaptures(FAccessContext Context, const FAddSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FSubSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FSubSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FSubSuspensionCaptures(FAccessContext Context, const FSubSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FMulSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FMulSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FMulSuspensionCaptures(FAccessContext Context, const FMulSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FDivSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FDivSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FDivSuspensionCaptures(FAccessContext Context, const FDivSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FModSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FModSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FModSuspensionCaptures(FAccessContext Context, const FModSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FMutableAddSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FMutableAddSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FMutableAddSuspensionCaptures(FAccessContext Context, const FMutableAddSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FNegSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Source;  

    FNegSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InSource)
        : Dest(Context, InDest)
        , Source(Context, InSource)
    {}

    FNegSuspensionCaptures(FAccessContext Context, const FNegSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Source(Context, Other.Source.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Source.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Source.Get(), "Source");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Source.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Source.Get(), "Source");
    }

};

struct FQuerySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Source;  

    FQuerySuspensionCaptures(FAccessContext Context, VValue InDest, VValue InSource)
        : Dest(Context, InDest)
        , Source(Context, InSource)
    {}

    FQuerySuspensionCaptures(FAccessContext Context, const FQuerySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Source(Context, Other.Source.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Source.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Source.Get(), "Source");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Source.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Source.Get(), "Source");
    }

};

struct FCallSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Callee;  
    TArray<TWriteBarrier<VValue>> Arguments;  // Captured variadic arguments.
    TWriteBarrier<VValue> EffectToken;
    TWriteBarrier<VValue> ReturnEffectToken;

    FCallSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InCallee, TArray<TWriteBarrier<VValue>>&& InArguments, VValue EffectToken, VValue ReturnEffectToken)
        : Dest(Context, InDest)
        , Callee(Context, InCallee)
        , Arguments(MoveTemp(InArguments))
        , EffectToken(Context, EffectToken)
        , ReturnEffectToken(Context, ReturnEffectToken)
    {}

    FCallSuspensionCaptures(FAccessContext Context, const FCallSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Callee(Context, Other.Callee.Get())
        , Arguments(Other.Arguments)
        , EffectToken(Context, Other.EffectToken.Get())
        ,  ReturnEffectToken(Context, Other.ReturnEffectToken.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Callee.Get());
        for (const auto& Operand : Arguments)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Callee.Get(), "Callee");
        for (int32 Index = 0; Index < Arguments.Num(); ++Index)
        {
            auto& Operand = Arguments[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Arguments", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Callee.Get());
        for (const auto& Operand : Arguments)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Callee.Get(), "Callee");
        for (int32 Index = 0; Index < Arguments.Num(); ++Index)
        {
            auto& Operand = Arguments[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Arguments", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

};

struct FVarGetSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Var;  
    TWriteBarrier<VValue> EffectToken;

    FVarGetSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InVar, VValue EffectToken)
        : Dest(Context, InDest)
        , Var(Context, InVar)
        , EffectToken(Context, EffectToken)
    {}

    FVarGetSuspensionCaptures(FAccessContext Context, const FVarGetSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Var(Context, Other.Var.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Var.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Var.Get(), "Var");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Var.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Var.Get(), "Var");
    }

};

struct FVarSetSuspensionCaptures
{
    TWriteBarrier<VValue> Var;  
    TWriteBarrier<VValue> Value;  
    TWriteBarrier<VValue> EffectToken;

    FVarSetSuspensionCaptures(FAccessContext Context, VValue InVar, VValue InValue, VValue EffectToken)
        : Var(Context, InVar)
        , Value(Context, InValue)
        , EffectToken(Context, EffectToken)
    {}

    FVarSetSuspensionCaptures(FAccessContext Context, const FVarSetSuspensionCaptures& Other)
        : Var(Context, Other.Var.Get())
        , Value(Context, Other.Value.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Var.Get());
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Var.Get(), "Var");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Var.Get());
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Var.Get(), "Var");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

};

struct FFreezeSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Value;  
    TWriteBarrier<VValue> EffectToken;

    FFreezeSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InValue, VValue EffectToken)
        : Dest(Context, InDest)
        , Value(Context, InValue)
        , EffectToken(Context, EffectToken)
    {}

    FFreezeSuspensionCaptures(FAccessContext Context, const FFreezeSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Value(Context, Other.Value.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

};

struct FMeltSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Value;  
    TWriteBarrier<VValue> EffectToken;

    FMeltSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InValue, VValue EffectToken)
        : Dest(Context, InDest)
        , Value(Context, InValue)
        , EffectToken(Context, EffectToken)
    {}

    FMeltSuspensionCaptures(FAccessContext Context, const FMeltSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Value(Context, Other.Value.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

};

struct FLengthSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Container;  

    FLengthSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InContainer)
        : Dest(Context, InDest)
        , Container(Context, InContainer)
    {}

    FLengthSuspensionCaptures(FAccessContext Context, const FLengthSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Container(Context, Other.Container.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Container.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Container.Get(), "Container");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Container.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Container.Get(), "Container");
    }

};

struct FIndexSetSuspensionCaptures
{
    TWriteBarrier<VValue> Container;  
    TWriteBarrier<VValue> Index;  
    TWriteBarrier<VValue> ValueToSet;  
    TWriteBarrier<VValue> EffectToken;

    FIndexSetSuspensionCaptures(FAccessContext Context, VValue InContainer, VValue InIndex, VValue InValueToSet, VValue EffectToken)
        : Container(Context, InContainer)
        , Index(Context, InIndex)
        , ValueToSet(Context, InValueToSet)
        , EffectToken(Context, EffectToken)
    {}

    FIndexSetSuspensionCaptures(FAccessContext Context, const FIndexSetSuspensionCaptures& Other)
        : Container(Context, Other.Container.Get())
        , Index(Context, Other.Index.Get())
        , ValueToSet(Context, Other.ValueToSet.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container.Get());
        Function(EOperandRole::Use, Index.Get());
        Function(EOperandRole::Use, ValueToSet.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container.Get(), "Container");
        Function(EOperandRole::Use, Index.Get(), "Index");
        Function(EOperandRole::Use, ValueToSet.Get(), "ValueToSet");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Container.Get());
        Function(EOperandRole::Use, Index.Get());
        Function(EOperandRole::Use, ValueToSet.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Container.Get(), "Container");
        Function(EOperandRole::Use, Index.Get(), "Index");
        Function(EOperandRole::Use, ValueToSet.Get(), "ValueToSet");
    }

};

struct FNewArraySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TArray<TWriteBarrier<VValue>> Values;  // Captured variadic arguments.

    FNewArraySuspensionCaptures(FAccessContext Context, VValue InDest, TArray<TWriteBarrier<VValue>>&& InValues)
        : Dest(Context, InDest)
        , Values(MoveTemp(InValues))
    {}

    FNewArraySuspensionCaptures(FAccessContext Context, const FNewArraySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Values(Other.Values)
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

};

struct FNewMutableArraySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TArray<TWriteBarrier<VValue>> Values;  // Captured variadic arguments.

    FNewMutableArraySuspensionCaptures(FAccessContext Context, VValue InDest, TArray<TWriteBarrier<VValue>>&& InValues)
        : Dest(Context, InDest)
        , Values(MoveTemp(InValues))
    {}

    FNewMutableArraySuspensionCaptures(FAccessContext Context, const FNewMutableArraySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Values(Other.Values)
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

};

struct FNewMutableArrayWithCapacitySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Size;  

    FNewMutableArrayWithCapacitySuspensionCaptures(FAccessContext Context, VValue InDest, VValue InSize)
        : Dest(Context, InDest)
        , Size(Context, InSize)
    {}

    FNewMutableArrayWithCapacitySuspensionCaptures(FAccessContext Context, const FNewMutableArrayWithCapacitySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Size(Context, Other.Size.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Size.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Size.Get(), "Size");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Size.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Size.Get(), "Size");
    }

};

struct FArrayAddSuspensionCaptures
{
    TWriteBarrier<VValue> Container;  
    TWriteBarrier<VValue> ValueToAdd;  

    FArrayAddSuspensionCaptures(FAccessContext Context, VValue InContainer, VValue InValueToAdd)
        : Container(Context, InContainer)
        , ValueToAdd(Context, InValueToAdd)
    {}

    FArrayAddSuspensionCaptures(FAccessContext Context, const FArrayAddSuspensionCaptures& Other)
        : Container(Context, Other.Container.Get())
        , ValueToAdd(Context, Other.ValueToAdd.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container.Get());
        Function(EOperandRole::Use, ValueToAdd.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container.Get(), "Container");
        Function(EOperandRole::Use, ValueToAdd.Get(), "ValueToAdd");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Container.Get());
        Function(EOperandRole::Use, ValueToAdd.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Container.Get(), "Container");
        Function(EOperandRole::Use, ValueToAdd.Get(), "ValueToAdd");
    }

};

struct FInPlaceMakeImmutableSuspensionCaptures
{
    TWriteBarrier<VValue> Container;  

    FInPlaceMakeImmutableSuspensionCaptures(FAccessContext Context, VValue InContainer)
        : Container(Context, InContainer)
    {}

    FInPlaceMakeImmutableSuspensionCaptures(FAccessContext Context, const FInPlaceMakeImmutableSuspensionCaptures& Other)
        : Container(Context, Other.Container.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Container.Get(), "Container");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Container.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Container.Get(), "Container");
    }

};

struct FNewOptionSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Value;  

    FNewOptionSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InValue)
        : Dest(Context, InDest)
        , Value(Context, InValue)
    {}

    FNewOptionSuspensionCaptures(FAccessContext Context, const FNewOptionSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Value(Context, Other.Value.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

};

struct FNewMapSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TArray<TWriteBarrier<VValue>> Keys;  // Captured variadic arguments.
    TArray<TWriteBarrier<VValue>> Values;  // Captured variadic arguments.

    FNewMapSuspensionCaptures(FAccessContext Context, VValue InDest, TArray<TWriteBarrier<VValue>>&& InKeys, TArray<TWriteBarrier<VValue>>&& InValues)
        : Dest(Context, InDest)
        , Keys(MoveTemp(InKeys))
        , Values(MoveTemp(InValues))
    {}

    FNewMapSuspensionCaptures(FAccessContext Context, const FNewMapSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Keys(Other.Keys)
        , Values(Other.Values)
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        for (const auto& Operand : Keys)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        for (int32 Index = 0; Index < Keys.Num(); ++Index)
        {
            auto& Operand = Keys[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Keys", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        for (const auto& Operand : Keys)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        for (int32 Index = 0; Index < Keys.Num(); ++Index)
        {
            auto& Operand = Keys[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Keys", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

};

struct FMapKeySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Map;  
    TWriteBarrier<VValue> Index;  

    FMapKeySuspensionCaptures(FAccessContext Context, VValue InDest, VValue InMap, VValue InIndex)
        : Dest(Context, InDest)
        , Map(Context, InMap)
        , Index(Context, InIndex)
    {}

    FMapKeySuspensionCaptures(FAccessContext Context, const FMapKeySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Map(Context, Other.Map.Get())
        , Index(Context, Other.Index.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Map.Get());
        Function(EOperandRole::Use, Index.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Map.Get(), "Map");
        Function(EOperandRole::Use, Index.Get(), "Index");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Map.Get());
        Function(EOperandRole::Use, Index.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Map.Get(), "Map");
        Function(EOperandRole::Use, Index.Get(), "Index");
    }

};

struct FMapValueSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Map;  
    TWriteBarrier<VValue> Index;  

    FMapValueSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InMap, VValue InIndex)
        : Dest(Context, InDest)
        , Map(Context, InMap)
        , Index(Context, InIndex)
    {}

    FMapValueSuspensionCaptures(FAccessContext Context, const FMapValueSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Map(Context, Other.Map.Get())
        , Index(Context, Other.Index.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Map.Get());
        Function(EOperandRole::Use, Index.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Map.Get(), "Map");
        Function(EOperandRole::Use, Index.Get(), "Index");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Map.Get());
        Function(EOperandRole::Use, Index.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Map.Get(), "Map");
        Function(EOperandRole::Use, Index.Get(), "Index");
    }

};

struct FNewClassSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VConstructor> Constructor;  
    TArray<TWriteBarrier<VValue>> Inherited;  // Captured variadic arguments.

    FNewClassSuspensionCaptures(FAccessContext Context, VValue InDest, const TWriteBarrier<VConstructor>& InConstructor, TArray<TWriteBarrier<VValue>>&& InInherited)
        : Dest(Context, InDest)
        , Constructor(InConstructor)
        , Inherited(MoveTemp(InInherited))
    {}

    FNewClassSuspensionCaptures(FAccessContext Context, const FNewClassSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Constructor(Other.Constructor)
        , Inherited(Other.Inherited)
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Immediate, Constructor);
        for (const auto& Operand : Inherited)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Immediate, Constructor, "Constructor");
        for (int32 Index = 0; Index < Inherited.Num(); ++Index)
        {
            auto& Operand = Inherited[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Inherited", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Immediate, Constructor);
        for (const auto& Operand : Inherited)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Immediate, Constructor, "Constructor");
        for (int32 Index = 0; Index < Inherited.Num(); ++Index)
        {
            auto& Operand = Inherited[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Inherited", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

};

struct FNewObjectSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Class;  
    TWriteBarrier<VUniqueStringSet> Fields;  
    TArray<TWriteBarrier<VValue>> Values;  // Captured variadic arguments.

    FNewObjectSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InClass, const TWriteBarrier<VUniqueStringSet>& InFields, TArray<TWriteBarrier<VValue>>&& InValues)
        : Dest(Context, InDest)
        , Class(Context, InClass)
        , Fields(InFields)
        , Values(MoveTemp(InValues))
    {}

    FNewObjectSuspensionCaptures(FAccessContext Context, const FNewObjectSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Class(Context, Other.Class.Get())
        , Fields(Other.Fields)
        , Values(Other.Values)
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Class.Get());
        Function(EOperandRole::Immediate, Fields);
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Class.Get(), "Class");
        Function(EOperandRole::Immediate, Fields, "Fields");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Class.Get());
        Function(EOperandRole::Immediate, Fields);
        for (const auto& Operand : Values)
        {
            Function(EOperandRole::Use, Operand.Get());
        }
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Class.Get(), "Class");
        Function(EOperandRole::Immediate, Fields, "Fields");
        for (int32 Index = 0; Index < Values.Num(); ++Index)
        {
            auto& Operand = Values[Index];
            const FString ArgName = FString::Format(TEXT("{0}{1}"), {"Values", Index});
            Function(EOperandRole::Use, Operand.Get(), TCHAR_TO_ANSI(*ArgName));
        }
    }

};

struct FLoadFieldSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Object;  
    TWriteBarrier<VUniqueString> Name;  

    FLoadFieldSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InObject, const TWriteBarrier<VUniqueString>& InName)
        : Dest(Context, InDest)
        , Object(Context, InObject)
        , Name(InName)
    {}

    FLoadFieldSuspensionCaptures(FAccessContext Context, const FLoadFieldSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Object(Context, Other.Object.Get())
        , Name(Other.Name)
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Object.Get());
        Function(EOperandRole::Immediate, Name);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Object.Get(), "Object");
        Function(EOperandRole::Immediate, Name, "Name");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, Object.Get());
        Function(EOperandRole::Immediate, Name);
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, Object.Get(), "Object");
        Function(EOperandRole::Immediate, Name, "Name");
    }

};

struct FUnifyFieldSuspensionCaptures
{
    TWriteBarrier<VValue> Object;  
    TWriteBarrier<VUniqueString> Name;  
    TWriteBarrier<VValue> Value;  

    FUnifyFieldSuspensionCaptures(FAccessContext Context, VValue InObject, const TWriteBarrier<VUniqueString>& InName, VValue InValue)
        : Object(Context, InObject)
        , Name(InName)
        , Value(Context, InValue)
    {}

    FUnifyFieldSuspensionCaptures(FAccessContext Context, const FUnifyFieldSuspensionCaptures& Other)
        : Object(Context, Other.Object.Get())
        , Name(Other.Name)
        , Value(Context, Other.Value.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::Use, Object.Get());
        Function(EOperandRole::Immediate, Name);
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::Use, Object.Get(), "Object");
        Function(EOperandRole::Immediate, Name, "Name");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::Use, Object.Get());
        Function(EOperandRole::Immediate, Name);
        Function(EOperandRole::Use, Value.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::Use, Object.Get(), "Object");
        Function(EOperandRole::Immediate, Name, "Name");
        Function(EOperandRole::Use, Value.Get(), "Value");
    }

};

struct FNeqSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FNeqSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FNeqSuspensionCaptures(FAccessContext Context, const FNeqSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FLtSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FLtSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FLtSuspensionCaptures(FAccessContext Context, const FLtSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FLteSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FLteSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FLteSuspensionCaptures(FAccessContext Context, const FLteSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FGtSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FGtSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FGtSuspensionCaptures(FAccessContext Context, const FGtSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

struct FGteSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FGteSuspensionCaptures(FAccessContext Context, VValue InDest, VValue InLeftSource, VValue InRightSource)
        : Dest(Context, InDest)
        , LeftSource(Context, InLeftSource)
        , RightSource(Context, InRightSource)
    {}

    FGteSuspensionCaptures(FAccessContext Context, const FGteSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function) const
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

    template <typename FunctionType>
    void ForEachOperand(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get());
        Function(EOperandRole::Use, LeftSource.Get());
        Function(EOperandRole::Use, RightSource.Get());
    }

    template <typename FunctionType>
    void ForEachOperandWithName(FunctionType Function)
    {
        Function(EOperandRole::UnifyDef, Dest.Get(), "Dest");
        Function(EOperandRole::Use, LeftSource.Get(), "LeftSource");
        Function(EOperandRole::Use, RightSource.Get(), "RightSource");
    }

};

} // namespace Verse
